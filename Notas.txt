LINKEO DE LIBRERIAS:
Se hace con las opciones -L y -l
-L es para una carpeta, -l es para un archivo
Si la compilacion da errores, buscar el error en google y ver la libreria que se necesita linkear
Hay dos formas de linkear, de forma estática y dinámica. La forma dinámica usa dll y necesita esos dll para que el programa se ejecute, es decir, 
si no están no puedes ejecutar el programa. La forma estática te mete todo lo que necesitas sin necesidad de los dll, directamente si el archivo 
está compilado puedes ejecutarlo.

GLFW
Solo es se usa para crear ventanas y manejar inputs
Para usar OpenGL se necesita una libreria extra, como puede ser GLAD o GLEW
Esa libreria se tiene que inicializar DESPUES DE CREAR EL CONTEXTO de la ventana, si no salta un error


OpenGL
Documentación en esta página: https://docs.gl/


VertexBuffer
Es literalmente un buffer pero que está en la GPU, al que le podemos meter info sobre cualquier cosa, por ejemplo, triángulos
El buffer está en la VRAM de la GPU
Luego, con ese buffer se hara una drawCall. La GPU va a leer la info de ese buffer y va a displayear lo que sea que le hayas puesto (triángulos)
Tenemos que decirle a la GPU cómo tiene que interpretar la info y cómo queremos que la dibuje. Esto es el maravilloso SHADER

Shaders
Es un codigo especial para la GPU, que permite interpretar info dentro de los buffers
Se ejecuta en la GPU!!! (es mucho más rápido que la CPU asiq es muy bueno)

https://www.youtube.com/watch?v=0p9VxImr7Y0&list=PLlrATfBNZ98foTJPJ_Ev03o2oq3-GGOS2&index=4&ab_channel=TheCherno
glGenBuffers(int cuantosBuffersQuieres, unsigned int elBuffer)
Se usa unsigned int porque al final no deja de ser una posicion de memoria con 4 bytes para almacenar datos
No vamos a usar ese int como tal, si no su posición en memoria

glBindBuffer(GLenum propósito, uint buffer)
Esto te selecciona el buffer, y con el propósito le dices qué quieres hacer con el buffer

glBufferData(propósito, tamañoDelBuffer, laInfo (toda junta), queVamosAHacer)
En queVamosAHacer hay varias opciones, Stream-Static-Dynamic + Draw-Read-Copy. Todo esto está bien explicado en la documentacion de arriba

Formas de dibujar:
glDrawArrays(loQueQuieresDibujar, dondeEmpiezasALeer, numeroDeVertices)
glDrawElements(loQueQuieresDibujar, numeroDeVertices, tipoDeDatoPrimitivo, punteroALosIndices (suele ser NULL) )
SE VA A DIBUJAR LO QUE HAYAMOS BINDEADO, para eso sirve bindear. Si hicieramos glBindBuffer(..., 0) no se dibujaría nada (el 0 es como null)
Es como photoshop, tienes que seleccionar lo que quieres modificar/pintar antes de hacer nada con eso

https://www.youtube.com/watch?v=x0H--CL2tUI&list=PLlrATfBNZ98foTJPJ_Ev03o2oq3-GGOS2&index=5&ab_channel=TheCherno
VertexAttributes
Necesitamos decirle a la GPU qué es lo que está recibiendo en el buffer
glVertexAttribPointer(indice, tamaño, tipoPrimitivo, normalized, stride, pointer)
- El indice te dice qué atributo estas viendo
- El tamaño es el número de tipos que tiene ese atributo. Puede tener de 1 a 4 (un solo número, o un vec4)
- El tipoPrimitivo es el tipo de los datos que hay en ese atributo, float, int...
- Normalized se usa, por ejemplo, en colores cuando tienes que tener un numero entre 0 y 1, pero tienes un numero entre 0 y 255. Lo podrias hacer tu, pero tambien lo puede hacer la GPU por ti.
- Stride es el número de bytes entre los diferentes Vertex (la longitud del Vertex). NOTA: los Vertex no tienen que ser solo posiciones, pueden tener tambien colores y otros atributos
- Pointer se refiere al offset en bytes entre los atributos dentro del mismo Vertex. Puede ser util usar offsetof() de C++ para conseguir esto (cuando se trabaja con una estructura definida)

https://www.youtube.com/watch?v=5W7JLgFCkwI&list=PLlrATfBNZ98foTJPJ_Ev03o2oq3-GGOS2&index=6&ab_channel=TheCherno
https://www.youtube.com/watch?v=71BLZwRGUJE&list=PLlrATfBNZ98foTJPJ_Ev03o2oq3-GGOS2&index=7&ab_channel=TheCherno
https://www.youtube.com/watch?v=2pv0Fbo-7ms&list=PLlrATfBNZ98foTJPJ_Ev03o2oq3-GGOS2&index=8&ab_channel=TheCherno
Shaders - Continuación
Hay dos tipos principales, vertex y fragment shaders 
El vertex shader se llama para cada vertex que tengamos. Especifica donde van a ir las posiciones de los vertex. Tambien te genera resultados para la siguiente fase, para el fragment shader
El fragment shader se llama para cada pixel que haya que dibujar
Realmente lo unico importante que he aprendido de esto de momento es a como pasar ficheros a string
He creado dos funciones, una para leer un único shader en un fichero, y otra para leer varios shaders en un mismo fichero.
Todavia no se la potencia que puede llegar a tener un shader, ni qué parámetros se le puede asignar, de momento solo se posicion y color

https://www.youtube.com/watch?v=MXNMC1YAxVQ&list=PLlrATfBNZ98foTJPJ_Ev03o2oq3-GGOS2&index=9&ab_channel=TheCherno
IndexBuffer
Permite reutilizar vertices existentes, por ejemplo, para dibujar un rectangulo. Podriamos hacerlo con dos triangulos, que ya sabemos dibujar, pero eso hace que los dos vertices que se tocan de cada triangulo estén repetidos (estariamos usando 6 vertices en vez de solo 4)
Cosas importantes que estoy leyendo: 
    ¿Como sabe OpenGL qué posiciones tiene que leer si no se las he pasado? Primero bindeamos el ArrayBuffer y luego el ElementArrayBuffer, por eso el ArrayBuffer "sigue bindeado", es como que el ArrayBuffer y el ElementArrayBuffer no se afectan entre ellos al bindear.
    IMPORTANTE: los indices tienen que ir en sentido antihorario para que se dibuje todo en el mismo sentido. Esto no importa mucho ahora, pero luego cuando rendericemos texturas y eso sí que hará falta para que la imagen no salga invertida!!
    TIENE QUE SER UNSIGNED, glDrawElements solo trata con datos sin signo

https://www.youtube.com/watch?v=FBbPWSOQ0-w&list=PLlrATfBNZ98foTJPJ_Ev03o2oq3-GGOS2&index=10&ab_channel=TheCherno
Errores
Hay una funcion muy bonita, glGetError(), que te devuelve uno de los errores, solo uno
Entonces lo que se hace para debuggear una seccion de codigo es limpiar todos los errores que hubiera antes, hacer la seccion y luego llamar a esa funcion. Para limpiar los errores de antes, se hace con un while comprobando que no queden errores, es decir, que la funcion no te devuelva un error. He creado dos funciones para hacer esto, aunque no es el mejor approach si no sabemos donde se puede estar formando el error
Tambien hay otra funcion, glDebugMessageCallback(), que da info más detallada del posible error, pero está para versiones recientes de OpenGL ( de la 4.3 en adelante)

https://www.youtube.com/watch?v=DE6Xlx_kbo0&list=PLlrATfBNZ98foTJPJ_Ev03o2oq3-GGOS2&index=13&ab_channel=TheCherno
Pasar variables de la CPU (C++) a la GPU (shaders)
Se hace declarando una variable de tipo uniform en el shader. Al ser uniform, se actualiza en cada drawCall. 
Para pasar realmente la info al shader tenemos que usar la funcion glUniform...(location, ...), por ejemplo, si queremos usar un vec4 en el shader, debemos usar la funcion glUniform4f(location, f1, f2, f3, f4)
Tenemos que pasarle la localizacion de la variable que tiene el uniform en el shader. Esta localizacion se obtiene con la funcion glGetUniformLocation(programa, nombreDeLaVariable)
Detalle tonto: el programa (linkeado con el shader) tiene que estar creado antes de poder obtener la localizacion (sería tonto querer obtener algo que no hemos definido todavia)

https://www.youtube.com/watch?v=Bcs56Mm-FJY&list=PLlrATfBNZ98foTJPJ_Ev03o2oq3-GGOS2&index=12&ab_channel=TheCherno
Vertex Arrays 
Pequeño detalle que comenta en el video: imaginemos el caso en el que bindeamos un ArrayBuffer y le especificamos los atributos que tiene el buffer, en nuestro caso las posiciones. Despues creamos otro buffer y lo bindeamos y hacemos lo que tengamos que hacer con él. Despues de eso, VOLVEMOS a bindear el primer buffer. ¿Tenemos que volver a especificar los atributos? SÍ, los atributos no se "guadran" con el buffer, cada vez que desbindeamos un buffer corremos el riesgo de que otro buffer haya modificado la informacion de los atributos, por lo que hay que volver a poner esa info. ¿Y eso que significa? Que si tuvieramos varios objetos que dibujar, tendriamos que estar todo el rato bindeando y especificando atributos para cada objeto que dibujamos. Esto es un rollo
Entonces, en vez de hacer un ArrayBuffer, podemos bindear un VertexArray, que si que guarda el estado de todo.
Realmente ya estamos usando un VertexArray, cuando llamamos a GLDebug(glEnableVertexAttribArray(0)). El 0 es como el VertexArray predeterminado, que viene en el Compatibility Profile por defecto. Pero si estuvieramos en el Core Profile, no tendriamos este VertexArray, tendriamos que bindearlo nosotros
¿Pero qué tiene de bueno bindearlo nosotros? QUE EL PROBLEMA DESAPARECE, el VertexArray guadra el estado del buffer y de sus atributos, y por eso no hay que especificarlos, ni siquiera hace falta volver a bindear el ArrayBuffer. 
Pero pero, ¿cual es el codigo que linkea el ArrayBuffer con el VertexArray?? Es la funcion glVertexAttribPointer, si tenemos bindeado el VertexArray y el ArrayBuffer, cuando llamamos a esa funcion, ambos se linkean. 
De momento no hablamos de linkear varios ArrayBuffers al mismo VertexArray, pero llegaremos. Pequeña preview: cuando bindeas otro ArrayBuffer, si llamas a la funcion glVertexAttribPointer con otro índice en el primer parámetro, este segundo ArrayBuffer tambien se linkea con el VertexArray. Los dos buffers estan linkeados al mismo VertexArray.